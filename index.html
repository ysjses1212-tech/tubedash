<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TubeDash</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            dark: { 800: '#1a1a2e', 900: '#0f0f1a' }
          }
        }
      }
    }
  </script>
  <style>
    body { background: linear-gradient(135deg, #0f0f1a 0%, #1a1a2e 100%); }
    .glass { background: rgba(255,255,255,0.05); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1); }
    .card-hover { transition: all 0.3s; }
    .card-hover:hover { transform: translateY(-2px); box-shadow: 0 8px 30px rgba(0,0,0,0.3); }
    .scrollbar-hide::-webkit-scrollbar { display: none; }
    .tag { display: inline-block; padding: 2px 8px; margin: 2px; border-radius: 12px; font-size: 11px; background: rgba(59,130,246,0.2); color: #60a5fa; }
    .shimmer { background: linear-gradient(90deg, rgba(255,255,255,0.03) 25%, rgba(255,255,255,0.08) 50%, rgba(255,255,255,0.03) 75%); background-size: 200% 100%; animation: shimmer 1.5s infinite; }
    @keyframes shimmer { 0% { background-position: -200% 0; } 100% { background-position: 200% 0; } }
  </style>
</head>
<body class="dark min-h-screen text-white">
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useEffect, useCallback, useMemo } = React;

    // ===== API 키 설정 (여기에 태연이 키 입력!) =====
    const API_KEYS = [
      'AIzaSy_AIzaSyCgbOY3gODsQCF0Ta5ie3v5tcLFlOIgzbE',
      'AIzaSy_AIzaSyAfI1c6Lg5tAaZp82C8i5-hdFUwvIagFWk',
      'AIzaSy_여기에_세번째키'
    ];
    
    const DAILY_QUOTA_LIMIT = 10000;
    const AUTO_SWITCH_THRESHOLD = 0.8; // 80%에서 자동 전환
    const WARNING_THRESHOLD = 0.7; // 70%에서 경고

    // ===== 아이콘 컴포넌트 =====
    const Icons = {
      Search: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" /></svg>,
      Video: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg>,
      Users: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197m13.5-9a2.5 2.5 0 11-5 0 2.5 2.5 0 015 0z" /></svg>,
      Settings: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /></svg>,
      Save: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 5a2 2 0 012-2h10a2 2 0 012 2v16l-7-3.5L5 21V5z" /></svg>,
      Trash: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>,
      Plus: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" /></svg>,
      X: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" /></svg>,
      Folder: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" /></svg>,
      Grid: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z" /></svg>,
      List: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 10h16M4 14h16M4 18h16" /></svg>,
      Key: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 7a2 2 0 012 2m4 0a6 6 0 01-7.743 5.743L11 17H9v2H7v2H4a1 1 0 01-1-1v-2.586a1 1 0 01.293-.707l5.964-5.964A6 6 0 1121 9z" /></svg>,
      Refresh: () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" /></svg>,
      ExternalLink: () => <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" /></svg>
    };

    // ===== 유틸리티 함수 =====
    const formatNumber = (num) => {
      if (!num) return '0';
      if (num >= 100000000) return (num / 100000000).toFixed(1) + '억';
      if (num >= 10000) return (num / 10000).toFixed(1) + '만';
      if (num >= 1000) return (num / 1000).toFixed(1) + '천';
      return num.toString();
    };

    const formatDate = (dateString) => {
      if (!dateString) return '';
      const date = new Date(dateString);
      return date.toLocaleDateString('ko-KR', { year: 'numeric', month: 'short', day: 'numeric' });
    };

    const parseDuration = (duration) => {
      if (!duration) return 0;
      const match = duration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
      if (!match) return 0;
      const hours = parseInt(match[1]) || 0;
      const minutes = parseInt(match[2]) || 0;
      const seconds = parseInt(match[3]) || 0;
      return hours * 3600 + minutes * 60 + seconds;
    };

    const formatDuration = (duration) => {
      const totalSeconds = parseDuration(duration);
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;
      if (hours > 0) return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    };

    const getVideoType = (duration) => {
      const seconds = parseDuration(duration);
      return seconds < 180 ? 'short' : 'long';
    };

    // ===== 메인 앱 =====
    function App() {
      // 기본 상태
      const [viewMode, setViewMode] = useState('card');
      const [isSettingsOpen, setIsSettingsOpen] = useState(false);
      const [toast, setToast] = useState(null);
      const [isLoading, setIsLoading] = useState(false);
      const [error, setError] = useState(null);
      const [currentTab, setCurrentTab] = useState('search');
      const [searchText, setSearchText] = useState('');
      const [searchVideos, setSearchVideos] = useState([]);
      const [nextPageToken, setNextPageToken] = useState(null);
      const [savedVideos, setSavedVideos] = useState([]);
      const [savedChannels, setSavedChannels] = useState([]);
      const [channelAnalysisVideos, setChannelAnalysisVideos] = useState([]);
      const [isChannelAnalysisActive, setIsChannelAnalysisActive] = useState(false);
      const [searchFilters, setSearchFilters] = useState({ type: 'all', date: 'all', subscribers: 'all', views: 'all' });
      const [analysisFilters, setAnalysisFilters] = useState({ type: 'all', date: 'all', views: 'all' });
      const [selectedCategory, setSelectedCategory] = useState('전체');
      const [savedVideoIds, setSavedVideoIds] = useState(new Set());
      const [savedChannelIds, setSavedChannelIds] = useState(new Set());
      
      // API 키 관련 상태
      const [currentKeyIndex, setCurrentKeyIndex] = useState(0);
      const [keyQuotas, setKeyQuotas] = useState(() => {
        const saved = localStorage.getItem('tubedash_key_quotas');
        if (saved) {
          const parsed = JSON.parse(saved);
          const today = new Date().toDateString();
          // 날짜가 바뀌면 리셋
          if (parsed.date !== today) {
            return { date: today, keys: API_KEYS.map(() => ({ used: 0 })) };
          }
          return parsed;
        }
        return { date: new Date().toDateString(), keys: API_KEYS.map(() => ({ used: 0 })) };
      });

      // Supabase 설정 (여기에 태연이 정보 입력!)
      const [settings, setSettings] = useState({ 
        supabaseUrl: 'https://rxuixdoqucgutqlxaqgr.supabase.co', 
        supabaseKey: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJ4dWl4ZG9xdWNndXRxbHhhcWdyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ1MzM4OTUsImV4cCI6MjA4MDEwOTg5NX0.ADR6Ppx_A0TUhgSnlkhKJ9_Nwm6RsfVMQmUiKNriAyE' 
      });
      
      // 모달 상태
      const [isAddChannelOpen, setIsAddChannelOpen] = useState(false);
      const [channelInput, setChannelInput] = useState('');
      const [isAddingChannel, setIsAddingChannel] = useState(false);
      const [isAddVideoOpen, setIsAddVideoOpen] = useState(false);
      const [videoInput, setVideoInput] = useState('');
      const [isAddingVideo, setIsAddingVideo] = useState(false);
      
      // 카테고리 모달 상태
      const [isCategoryModalOpen, setIsCategoryModalOpen] = useState(false);
      const [pendingChannel, setPendingChannel] = useState(null);
      const [isVideoCategoryModalOpen, setIsVideoCategoryModalOpen] = useState(false);
      const [pendingVideoData, setPendingVideoData] = useState(null);
      const [selectedVideoCategory, setSelectedVideoCategory] = useState('전체');
      const [videoTypeFilter, setVideoTypeFilter] = useState('all');
      const [categoryChangeMode, setCategoryChangeMode] = useState(false);

      // 현재 사용 중인 API 키
      const currentApiKey = API_KEYS[currentKeyIndex];
      const currentKeyUsage = keyQuotas.keys[currentKeyIndex]?.used || 0;
      const usagePercent = (currentKeyUsage / DAILY_QUOTA_LIMIT) * 100;

      // Supabase 클라이언트
      const supabase = useMemo(() => {
        if (settings.supabaseUrl && settings.supabaseKey) {
          return window.supabase.createClient(settings.supabaseUrl, settings.supabaseKey);
        }
        return null;
      }, [settings.supabaseUrl, settings.supabaseKey]);

      // API 사용량 기록 및 자동 키 전환
      const recordQuotaUsage = useCallback((amount) => {
        setKeyQuotas(prev => {
          const newQuotas = { ...prev };
          newQuotas.keys = [...prev.keys];
          newQuotas.keys[currentKeyIndex] = { 
            used: (prev.keys[currentKeyIndex]?.used || 0) + amount 
          };
          
          // localStorage에 저장
          localStorage.setItem('tubedash_key_quotas', JSON.stringify(newQuotas));
          
          // 자동 전환 체크 (80% 이상이면 다음 키로)
          const newUsage = newQuotas.keys[currentKeyIndex].used;
          if (newUsage >= DAILY_QUOTA_LIMIT * AUTO_SWITCH_THRESHOLD) {
            const nextIndex = (currentKeyIndex + 1) % API_KEYS.length;
            if (nextIndex !== currentKeyIndex && (newQuotas.keys[nextIndex]?.used || 0) < DAILY_QUOTA_LIMIT * AUTO_SWITCH_THRESHOLD) {
              setCurrentKeyIndex(nextIndex);
              showToast(`API 키 자동 전환! (키 ${nextIndex + 1}번으로 변경)`, 'info');
            }
          }
          
          return newQuotas;
        });
      }, [currentKeyIndex]);

      // 토스트 메시지
      const showToast = (message, type = 'success') => {
        setToast({ message, type });
        setTimeout(() => setToast(null), 3000);
      };

      // 기존 카테고리 목록 가져오기
      const getExistingCategories = () => {
        const categories = savedChannels.map(ch => ch.category).filter(Boolean);
        return [...new Set(categories)];
      };

      const getExistingVideoCategories = () => {
        const categories = savedVideos.map(v => v.category).filter(Boolean);
        return [...new Set(categories)];
      };

      // 저장된 데이터 불러오기
      const fetchSavedAssets = useCallback(async () => {
        if (!supabase) return;
        
        try {
          const { data: videos, error: videosError } = await supabase
            .from('video_assets')
            .select('*')
            .order('created_at', { ascending: false });
          
          if (videosError) throw videosError;
          
          const { data: channels, error: channelsError } = await supabase
            .from('channel_assets')
            .select('*')
            .order('created_at', { ascending: false });
          
          if (channelsError) throw channelsError;
          
          const formattedVideos = (videos || []).map(v => ({
            id: v.id,
            videoId: v.video_id,
            title: v.title,
            description: v.description,
            thumbnail: v.thumbnail,
            channelTitle: v.channel_title,
            channelId: v.channel_id,
            viewCount: v.view_count,
            likeCount: v.like_count,
            commentCount: v.comment_count,
            subscriberCount: v.subscriber_count,
            publishedAt: v.published_at,
            duration: v.duration,
            tags: v.tags || [],
            memo: v.memo,
            category: v.category || '일반',
            createdAt: v.created_at
          }));
          
          const formattedChannels = (channels || []).map(ch => ({
            id: ch.id,
            channelId: ch.channel_id,
            channelTitle: ch.channel_title,
            thumbnail: ch.thumbnail,
            subscriberCount: ch.subscriber_count,
            videoCount: ch.video_count,
            viewCount: ch.view_count,
            category: ch.category,
            createdAt: ch.created_at
          }));
          
          setSavedVideos(formattedVideos);
          setSavedChannels(formattedChannels);
          setSavedVideoIds(new Set(formattedVideos.map(v => v.videoId)));
          setSavedChannelIds(new Set(formattedChannels.map(ch => ch.channelId)));
        } catch (err) {
          console.error('데이터 불러오기 실패:', err);
          showToast('데이터 불러오기 실패', 'error');
        }
      }, [supabase]);

      useEffect(() => {
        fetchSavedAssets();
      }, [fetchSavedAssets]);

      // YouTube 검색
      const searchYouTube = async (query, pageToken = null) => {
        if (!currentApiKey) {
          showToast('API 키를 설정해주세요', 'error');
          return;
        }
        
        setIsLoading(true);
        setError(null);
        
        try {
          let searchUrl;
          let quotaCost = 0;
          
          if (query.trim()) {
            searchUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(query)}&type=video&maxResults=20&key=${currentApiKey}${pageToken ? `&pageToken=${pageToken}` : ''}`;
            quotaCost = 100;
          } else {
            searchUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet,statistics,contentDetails&chart=mostPopular&regionCode=KR&maxResults=20&key=${currentApiKey}${pageToken ? `&pageToken=${pageToken}` : ''}`;
            quotaCost = 1;
          }
          
          const searchRes = await fetch(searchUrl);
          const searchData = await searchRes.json();
          
          if (searchData.error) throw new Error(searchData.error.message);
          
          recordQuotaUsage(quotaCost);
          
          let videos = [];
          
          if (query.trim()) {
            const videoIds = searchData.items.map(item => item.id.videoId).join(',');
            const detailsUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet,statistics,contentDetails&id=${videoIds}&key=${currentApiKey}`;
            const detailsRes = await fetch(detailsUrl);
            const detailsData = await detailsRes.json();
            
            recordQuotaUsage(1);
            
            const channelIds = [...new Set(detailsData.items.map(item => item.snippet.channelId))].join(',');
            const channelsUrl = `https://www.googleapis.com/youtube/v3/channels?part=statistics&id=${channelIds}&key=${currentApiKey}`;
            const channelsRes = await fetch(channelsUrl);
            const channelsData = await channelsRes.json();
            
            recordQuotaUsage(1);
            
            const channelStats = {};
            channelsData.items.forEach(ch => {
              channelStats[ch.id] = ch.statistics;
            });
            
            videos = detailsData.items.map(item => ({
              videoId: item.id,
              title: item.snippet.title,
              description: item.snippet.description,
              thumbnail: item.snippet.thumbnails.high?.url || item.snippet.thumbnails.default?.url,
              channelTitle: item.snippet.channelTitle,
              channelId: item.snippet.channelId,
              publishedAt: item.snippet.publishedAt,
              viewCount: parseInt(item.statistics.viewCount) || 0,
              likeCount: parseInt(item.statistics.likeCount) || 0,
              commentCount: parseInt(item.statistics.commentCount) || 0,
              subscriberCount: parseInt(channelStats[item.snippet.channelId]?.subscriberCount) || 0,
              duration: item.contentDetails.duration,
              tags: item.snippet.tags || []
            }));
          } else {
            const channelIds = [...new Set(searchData.items.map(item => item.snippet.channelId))].join(',');
            const channelsUrl = `https://www.googleapis.com/youtube/v3/channels?part=statistics&id=${channelIds}&key=${currentApiKey}`;
            const channelsRes = await fetch(channelsUrl);
            const channelsData = await channelsRes.json();
            
            recordQuotaUsage(1);
            
            const channelStats = {};
            channelsData.items.forEach(ch => {
              channelStats[ch.id] = ch.statistics;
            });
            
            videos = searchData.items.map(item => ({
              videoId: item.id,
              title: item.snippet.title,
              description: item.snippet.description,
              thumbnail: item.snippet.thumbnails.high?.url || item.snippet.thumbnails.default?.url,
              channelTitle: item.snippet.channelTitle,
              channelId: item.snippet.channelId,
              publishedAt: item.snippet.publishedAt,
              viewCount: parseInt(item.statistics.viewCount) || 0,
              likeCount: parseInt(item.statistics.likeCount) || 0,
              commentCount: parseInt(item.statistics.commentCount) || 0,
              subscriberCount: parseInt(channelStats[item.snippet.channelId]?.subscriberCount) || 0,
              duration: item.contentDetails.duration,
              tags: item.snippet.tags || []
            }));
          }
          
          // 필터 적용
          let filtered = videos;
          
          if (searchFilters.type === 'short') {
            filtered = filtered.filter(v => parseDuration(v.duration) < 180);
          } else if (searchFilters.type === 'long') {
            filtered = filtered.filter(v => parseDuration(v.duration) >= 180);
          }
          
          if (searchFilters.subscribers !== 'all') {
            const subLimit = parseInt(searchFilters.subscribers);
            filtered = filtered.filter(v => v.subscriberCount >= subLimit);
          }
          
          if (searchFilters.views !== 'all') {
            const viewLimit = parseInt(searchFilters.views);
            filtered = filtered.filter(v => v.viewCount >= viewLimit);
          }
          
          if (pageToken) {
            setSearchVideos(prev => [...prev, ...filtered]);
          } else {
            setSearchVideos(filtered);
          }
          setNextPageToken(searchData.nextPageToken || null);
          
        } catch (err) {
          console.error('검색 실패:', err);
          setError(err.message);
          showToast('검색 실패: ' + err.message, 'error');
        } finally {
          setIsLoading(false);
        }
      };

      // 영상 저장 (카테고리 모달 열기)
      const handleSaveVideo = (video) => {
        if (savedVideoIds.has(video.videoId)) {
          showToast('이미 저장된 영상입니다', 'error');
          return;
        }
        setPendingVideoData(video);
        setCategoryChangeMode(false);
        setIsVideoCategoryModalOpen(true);
      };

      // 영상 저장 확정
      const confirmSaveVideoWithCategory = async (category) => {
        if (!supabase || !pendingVideoData) return;
        
        try {
          if (categoryChangeMode) {
            // 카테고리 변경 모드
            const { error } = await supabase
              .from('video_assets')
              .update({ category })
              .eq('video_id', pendingVideoData.videoId);
            
            if (error) throw error;
            showToast('카테고리가 변경되었습니다', 'success');
          } else {
            // 새 영상 저장 모드
            const { error } = await supabase
              .from('video_assets')
              .insert([{
                video_id: pendingVideoData.videoId,
                title: pendingVideoData.title,
                description: pendingVideoData.description,
                thumbnail: pendingVideoData.thumbnail,
                channel_title: pendingVideoData.channelTitle,
                channel_id: pendingVideoData.channelId,
                view_count: pendingVideoData.viewCount,
                like_count: pendingVideoData.likeCount,
                comment_count: pendingVideoData.commentCount,
                subscriber_count: pendingVideoData.subscriberCount,
                published_at: pendingVideoData.publishedAt,
                duration: pendingVideoData.duration,
                tags: pendingVideoData.tags,
                category
              }]);
            
            if (error) throw error;
            showToast('영상이 저장되었습니다', 'success');
          }
          
          fetchSavedAssets();
        } catch (err) {
          console.error('저장 실패:', err);
          showToast('저장 실패', 'error');
        } finally {
          setIsVideoCategoryModalOpen(false);
          setPendingVideoData(null);
          setCategoryChangeMode(false);
        }
      };

      // 영상 카테고리 변경
      const handleChangeVideoCategory = (video) => {
        setPendingVideoData(video);
        setCategoryChangeMode(true);
        setIsVideoCategoryModalOpen(true);
      };

      // 영상 삭제
      const handleDeleteVideo = async (videoId) => {
        if (!supabase) return;
        
        try {
          const { error } = await supabase
            .from('video_assets')
            .delete()
            .eq('video_id', videoId);
          
          if (error) throw error;
          showToast('영상이 삭제되었습니다', 'success');
          fetchSavedAssets();
        } catch (err) {
          console.error('삭제 실패:', err);
          showToast('삭제 실패', 'error');
        }
      };

      // 채널 저장 (카테고리 모달 열기)
      const handleSaveChannel = (video) => {
        if (savedChannelIds.has(video.channelId)) {
          showToast('이미 저장된 채널입니다', 'error');
          return;
        }
        setPendingChannel(video);
        setCategoryChangeMode(false);
        setIsCategoryModalOpen(true);
      };

      // 채널 저장 확정
      const confirmSaveChannel = async (category) => {
        if (!supabase || !pendingChannel) return;
        
        try {
          if (categoryChangeMode) {
            // 카테고리 변경 모드
            const { error } = await supabase
              .from('channel_assets')
              .update({ category })
              .eq('channel_id', pendingChannel.channelId);
            
            if (error) throw error;
            showToast('카테고리가 변경되었습니다', 'success');
          } else {
            // 새 채널 저장 모드
            const { error } = await supabase
              .from('channel_assets')
              .insert([{
                channel_id: pendingChannel.channelId,
                channel_title: pendingChannel.channelTitle,
                thumbnail: pendingChannel.thumbnail || pendingChannel.channelThumbnail,
                subscriber_count: pendingChannel.subscriberCount,
                video_count: pendingChannel.videoCount || 0,
                view_count: pendingChannel.viewCount || 0,
                category
              }]);
            
            if (error) throw error;
            showToast('채널이 저장되었습니다', 'success');
          }
          
          fetchSavedAssets();
        } catch (err) {
          console.error('저장 실패:', err);
          showToast('저장 실패', 'error');
        } finally {
          setIsCategoryModalOpen(false);
          setPendingChannel(null);
          setCategoryChangeMode(false);
        }
      };

      // 채널 카테고리 변경
      const handleChangeCategory = (channel) => {
        setPendingChannel(channel);
        setCategoryChangeMode(true);
        setIsCategoryModalOpen(true);
      };

      // 채널 삭제
      const handleDeleteChannel = async (channelId) => {
        if (!supabase) return;
        
        try {
          const { error } = await supabase
            .from('channel_assets')
            .delete()
            .eq('channel_id', channelId);
          
          if (error) throw error;
          showToast('채널이 삭제되었습니다', 'success');
          fetchSavedAssets();
        } catch (err) {
          console.error('삭제 실패:', err);
          showToast('삭제 실패', 'error');
        }
      };

      // 채널 직접 추가
      const extractChannelId = (input) => {
        const patterns = [
          /youtube\.com\/channel\/(UC[\w-]+)/,
          /youtube\.com\/@([\w-]+)/,
          /youtube\.com\/c\/([\w-]+)/,
          /^@?([\w-]+)$/,
          /^(UC[\w-]+)$/
        ];
        
        for (const pattern of patterns) {
          const match = input.match(pattern);
          if (match) return { id: match[1], isHandle: !match[1].startsWith('UC') };
        }
        return null;
      };

      const handleAddChannelByUrl = async () => {
        if (!channelInput.trim() || !currentApiKey) return;
        
        setIsAddingChannel(true);
        
        try {
          const extracted = extractChannelId(channelInput.trim());
          if (!extracted) {
            showToast('올바른 채널 URL 또는 핸들을 입력해주세요', 'error');
            return;
          }
          
          let channelData;
          
          if (extracted.isHandle) {
            // 핸들로 검색 (101 쿼터)
            const searchUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(extracted.id)}&type=channel&maxResults=1&key=${currentApiKey}`;
            const searchRes = await fetch(searchUrl);
            const searchData = await searchRes.json();
            
            if (searchData.error) throw new Error(searchData.error.message);
            recordQuotaUsage(100);
            
            if (!searchData.items?.length) {
              showToast('채널을 찾을 수 없습니다', 'error');
              return;
            }
            
            const channelId = searchData.items[0].snippet.channelId;
            const channelUrl = `https://www.googleapis.com/youtube/v3/channels?part=snippet,statistics&id=${channelId}&key=${currentApiKey}`;
            const channelRes = await fetch(channelUrl);
            channelData = await channelRes.json();
            recordQuotaUsage(1);
          } else {
            // UC ID로 직접 조회 (1 쿼터)
            const channelUrl = `https://www.googleapis.com/youtube/v3/channels?part=snippet,statistics&id=${extracted.id}&key=${currentApiKey}`;
            const channelRes = await fetch(channelUrl);
            channelData = await channelRes.json();
            recordQuotaUsage(1);
          }
          
          if (channelData.error) throw new Error(channelData.error.message);
          if (!channelData.items?.length) {
            showToast('채널을 찾을 수 없습니다', 'error');
            return;
          }
          
          const ch = channelData.items[0];
          
          if (savedChannelIds.has(ch.id)) {
            showToast('이미 저장된 채널입니다', 'error');
            return;
          }
          
          // 카테고리 선택 모달 열기
          setPendingChannel({
            channelId: ch.id,
            channelTitle: ch.snippet.title,
            thumbnail: ch.snippet.thumbnails.default?.url,
            subscriberCount: parseInt(ch.statistics.subscriberCount) || 0,
            videoCount: parseInt(ch.statistics.videoCount) || 0,
            viewCount: parseInt(ch.statistics.viewCount) || 0
          });
          setCategoryChangeMode(false);
          setIsAddChannelOpen(false);
          setChannelInput('');
          setIsCategoryModalOpen(true);
          
        } catch (err) {
          console.error('채널 추가 실패:', err);
          showToast('채널 추가 실패: ' + err.message, 'error');
        } finally {
          setIsAddingChannel(false);
        }
      };

      // 영상 직접 추가
      const extractVideoId = (input) => {
        const patterns = [
          /youtube\.com\/watch\?v=([\w-]+)/,
          /youtu\.be\/([\w-]+)/,
          /youtube\.com\/embed\/([\w-]+)/,
          /^([\w-]{11})$/
        ];
        
        for (const pattern of patterns) {
          const match = input.match(pattern);
          if (match) return match[1];
        }
        return null;
      };

      const handleAddVideoByUrl = async () => {
        if (!videoInput.trim() || !currentApiKey) return;
        
        setIsAddingVideo(true);
        
        try {
          const videoId = extractVideoId(videoInput.trim());
          if (!videoId) {
            showToast('올바른 영상 URL을 입력해주세요', 'error');
            return;
          }
          
          if (savedVideoIds.has(videoId)) {
            showToast('이미 저장된 영상입니다', 'error');
            return;
          }
          
          const videoUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet,statistics,contentDetails&id=${videoId}&key=${currentApiKey}`;
          const videoRes = await fetch(videoUrl);
          const videoData = await videoRes.json();
          
          if (videoData.error) throw new Error(videoData.error.message);
          recordQuotaUsage(1);
          
          if (!videoData.items?.length) {
            showToast('영상을 찾을 수 없습니다', 'error');
            return;
          }
          
          const v = videoData.items[0];
          
          const channelUrl = `https://www.googleapis.com/youtube/v3/channels?part=statistics&id=${v.snippet.channelId}&key=${currentApiKey}`;
          const channelRes = await fetch(channelUrl);
          const channelData = await channelRes.json();
          recordQuotaUsage(1);
          
          const subscriberCount = channelData.items?.[0]?.statistics?.subscriberCount || 0;
          
          setPendingVideoData({
            videoId: v.id,
            title: v.snippet.title,
            description: v.snippet.description,
            thumbnail: v.snippet.thumbnails.high?.url || v.snippet.thumbnails.default?.url,
            channelTitle: v.snippet.channelTitle,
            channelId: v.snippet.channelId,
            viewCount: parseInt(v.statistics.viewCount) || 0,
            likeCount: parseInt(v.statistics.likeCount) || 0,
            commentCount: parseInt(v.statistics.commentCount) || 0,
            subscriberCount: parseInt(subscriberCount),
            publishedAt: v.snippet.publishedAt,
            duration: v.contentDetails.duration,
            tags: v.snippet.tags || []
          });
          setCategoryChangeMode(false);
          setIsAddVideoOpen(false);
          setVideoInput('');
          setIsVideoCategoryModalOpen(true);
          
        } catch (err) {
          console.error('영상 추가 실패:', err);
          showToast('영상 추가 실패: ' + err.message, 'error');
        } finally {
          setIsAddingVideo(false);
        }
      };

      // 필터링된 목록
      const filteredVideos = useMemo(() => {
        let list = savedVideos;
        
        if (selectedVideoCategory !== '전체') {
          list = list.filter(v => v.category === selectedVideoCategory);
        }
        
        if (videoTypeFilter === 'short') {
          list = list.filter(v => parseDuration(v.duration) < 180);
        } else if (videoTypeFilter === 'long') {
          list = list.filter(v => parseDuration(v.duration) >= 180);
        }
        
        return list;
      }, [savedVideos, selectedVideoCategory, videoTypeFilter]);

      const filteredChannels = useMemo(() => {
        if (selectedCategory === '전체') return savedChannels;
        return savedChannels.filter(ch => ch.category === selectedCategory);
      }, [savedChannels, selectedCategory]);

      // 수동 키 전환
      const switchApiKey = (index) => {
        if (index >= 0 && index < API_KEYS.length) {
          setCurrentKeyIndex(index);
          showToast(`API 키 ${index + 1}번으로 전환됨`, 'info');
        }
      };

      // 할당량 리셋
      const resetQuotas = () => {
        const newQuotas = { date: new Date().toDateString(), keys: API_KEYS.map(() => ({ used: 0 })) };
        setKeyQuotas(newQuotas);
        localStorage.setItem('tubedash_key_quotas', JSON.stringify(newQuotas));
        showToast('할당량이 초기화되었습니다', 'success');
      };

      // 할당량 표시 색상
      const getQuotaColor = () => {
        if (usagePercent >= 80) return 'bg-red-500';
        if (usagePercent >= 70) return 'bg-yellow-500';
        return 'bg-green-500';
      };

      const getQuotaTextColor = () => {
        if (usagePercent >= 80) return 'text-red-400';
        if (usagePercent >= 70) return 'text-yellow-400';
        return 'text-green-400';
      };

      return (
        <div className="min-h-screen p-4">
          {/* 헤더 */}
          <header className="glass rounded-xl p-4 mb-6">
            <div className="flex items-center justify-between">
              <h1 className="text-2xl font-bold bg-gradient-to-r from-blue-400 to-purple-500 bg-clip-text text-transparent">
                TubeDash
              </h1>
              
              {/* API 할당량 표시 */}
              <div className="flex items-center gap-4">
                <div className="flex items-center gap-2">
                  <div className="w-32 h-2 bg-gray-700 rounded-full overflow-hidden">
                    <div 
                      className={`h-full ${getQuotaColor()} transition-all`} 
                      style={{ width: `${Math.min(usagePercent, 100)}%` }}
                    />
                  </div>
                  <span className={`text-xs ${getQuotaTextColor()}`}>
                    키{currentKeyIndex + 1}: {usagePercent.toFixed(1)}%
                  </span>
                </div>
                
                <button
                  onClick={() => setIsSettingsOpen(true)}
                  className="p-2 hover:bg-white/10 rounded-lg transition"
                >
                  <Icons.Settings />
                </button>
              </div>
            </div>
            
            {/* 탭 */}
            <div className="flex gap-2 mt-4">
              {[
                { id: 'search', label: '검색', icon: Icons.Search },
                { id: 'videos', label: '영상 보관함', icon: Icons.Video },
                { id: 'channels', label: '채널 보관함', icon: Icons.Users }
              ].map(tab => (
                <button
                  key={tab.id}
                  onClick={() => setCurrentTab(tab.id)}
                  className={`flex items-center gap-2 px-4 py-2 rounded-lg transition ${
                    currentTab === tab.id 
                      ? 'bg-blue-600 text-white' 
                      : 'hover:bg-white/10 text-gray-400'
                  }`}
                >
                  <tab.icon />
                  <span>{tab.label}</span>
                  {tab.id === 'videos' && savedVideos.length > 0 && (
                    <span className="bg-blue-500/30 px-2 py-0.5 rounded-full text-xs">
                      {savedVideos.length}
                    </span>
                  )}
                  {tab.id === 'channels' && savedChannels.length > 0 && (
                    <span className="bg-blue-500/30 px-2 py-0.5 rounded-full text-xs">
                      {savedChannels.length}
                    </span>
                  )}
                </button>
              ))}
            </div>
          </header>

          {/* 검색 탭 */}
          {currentTab === 'search' && (
            <div className="space-y-4">
              <div className="glass rounded-xl p-4">
                <div className="flex gap-2">
                  <input
                    type="text"
                    value={searchText}
                    onChange={(e) => setSearchText(e.target.value)}
                    onKeyPress={(e) => e.key === 'Enter' && searchYouTube(searchText)}
                    placeholder="검색어를 입력하세요 (비워두면 인기 영상)"
                    className="flex-1 bg-white/10 border border-white/20 rounded-lg px-4 py-2 focus:outline-none focus:border-blue-500"
                  />
                  <button
                    onClick={() => searchYouTube(searchText)}
                    disabled={isLoading}
                    className="bg-blue-600 hover:bg-blue-700 px-6 py-2 rounded-lg transition disabled:opacity-50"
                  >
                    {isLoading ? '검색 중...' : '검색'}
                  </button>
                </div>
                
                {/* 필터 */}
                <div className="flex flex-wrap gap-2 mt-3">
                  <select
                    value={searchFilters.type}
                    onChange={(e) => setSearchFilters(f => ({ ...f, type: e.target.value }))}
                    className="bg-white/10 border border-white/20 rounded-lg px-3 py-1 text-sm"
                  >
                    <option value="all">전체 길이</option>
                    <option value="short">숏폼 (3분 미만)</option>
                    <option value="long">롱폼 (3분 이상)</option>
                  </select>
                  
                  <select
                    value={searchFilters.subscribers}
                    onChange={(e) => setSearchFilters(f => ({ ...f, subscribers: e.target.value }))}
                    className="bg-white/10 border border-white/20 rounded-lg px-3 py-1 text-sm"
                  >
                    <option value="all">구독자 전체</option>
                    <option value="1000">1천↑</option>
                    <option value="10000">1만↑</option>
                    <option value="100000">10만↑</option>
                    <option value="1000000">100만↑</option>
                  </select>
                  
                  <select
                    value={searchFilters.views}
                    onChange={(e) => setSearchFilters(f => ({ ...f, views: e.target.value }))}
                    className="bg-white/10 border border-white/20 rounded-lg px-3 py-1 text-sm"
                  >
                    <option value="all">조회수 전체</option>
                    <option value="1000">1천↑</option>
                    <option value="10000">1만↑</option>
                    <option value="100000">10만↑</option>
                    <option value="1000000">100만↑</option>
                  </select>
                </div>
              </div>

              {/* 검색 결과 */}
              {searchVideos.length > 0 && (
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
                  {searchVideos.map(video => (
                    <div key={video.videoId} className="glass rounded-xl overflow-hidden card-hover">
                      <a href={`https://youtube.com/watch?v=${video.videoId}`} target="_blank" rel="noopener noreferrer">
                        <div className="relative">
                          <img src={video.thumbnail} alt={video.title} className="w-full aspect-video object-cover" />
                          <span className="absolute bottom-2 right-2 bg-black/80 px-2 py-0.5 rounded text-xs">
                            {formatDuration(video.duration)}
                          </span>
                        </div>
                      </a>
                      <div className="p-3">
                        <h3 className="font-medium line-clamp-2 text-sm mb-2">{video.title}</h3>
                        <p className="text-gray-400 text-xs mb-1">{video.channelTitle}</p>
                        <div className="flex items-center justify-between text-xs text-gray-500">
                          <span>조회수 {formatNumber(video.viewCount)}</span>
                          <span>구독자 {formatNumber(video.subscriberCount)}</span>
                        </div>
                        <div className="flex gap-2 mt-3">
                          <button
                            onClick={() => handleSaveVideo(video)}
                            disabled={savedVideoIds.has(video.videoId)}
                            className="flex-1 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 py-1.5 rounded-lg text-xs transition"
                          >
                            {savedVideoIds.has(video.videoId) ? '저장됨' : '영상 저장'}
                          </button>
                          <button
                            onClick={() => handleSaveChannel(video)}
                            disabled={savedChannelIds.has(video.channelId)}
                            className="flex-1 bg-purple-600 hover:bg-purple-700 disabled:bg-gray-600 py-1.5 rounded-lg text-xs transition"
                          >
                            {savedChannelIds.has(video.channelId) ? '저장됨' : '채널 저장'}
                          </button>
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              )}
              
              {nextPageToken && (
                <div className="text-center">
                  <button
                    onClick={() => searchYouTube(searchText, nextPageToken)}
                    disabled={isLoading}
                    className="bg-white/10 hover:bg-white/20 px-6 py-2 rounded-lg transition"
                  >
                    더 보기
                  </button>
                </div>
              )}
            </div>
          )}

          {/* 영상 보관함 탭 */}
          {currentTab === 'videos' && (
            <div className="space-y-4">
              <div className="glass rounded-xl p-4">
                <div className="flex flex-wrap items-center justify-between gap-4">
                  <div className="flex flex-wrap gap-2">
                    <select
                      value={selectedVideoCategory}
                      onChange={(e) => setSelectedVideoCategory(e.target.value)}
                      className="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm"
                    >
                      <option value="전체">전체 카테고리</option>
                      {getExistingVideoCategories().map(cat => (
                        <option key={cat} value={cat}>{cat}</option>
                      ))}
                    </select>
                    
                    <div className="flex gap-1">
                      {[
                        { id: 'all', label: '전체' },
                        { id: 'short', label: '숏폼' },
                        { id: 'long', label: '롱폼' }
                      ].map(type => (
                        <button
                          key={type.id}
                          onClick={() => setVideoTypeFilter(type.id)}
                          className={`px-3 py-2 rounded-lg text-sm transition ${
                            videoTypeFilter === type.id
                              ? 'bg-blue-600 text-white'
                              : 'bg-white/10 hover:bg-white/20'
                          }`}
                        >
                          {type.label}
                        </button>
                      ))}
                    </div>
                  </div>
                  
                  <div className="flex gap-2">
                    <button
                      onClick={() => setIsAddVideoOpen(true)}
                      className="flex items-center gap-2 bg-green-600 hover:bg-green-700 px-4 py-2 rounded-lg text-sm transition"
                    >
                      <Icons.Plus />
                      영상 추가
                    </button>
                    
                    <div className="flex gap-1 bg-white/10 rounded-lg p-1">
                      <button
                        onClick={() => setViewMode('card')}
                        className={`p-2 rounded ${viewMode === 'card' ? 'bg-white/20' : ''}`}
                      >
                        <Icons.Grid />
                      </button>
                      <button
                        onClick={() => setViewMode('list')}
                        className={`p-2 rounded ${viewMode === 'list' ? 'bg-white/20' : ''}`}
                      >
                        <Icons.List />
                      </button>
                    </div>
                  </div>
                </div>
              </div>

              {viewMode === 'card' ? (
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
                  {filteredVideos.map(video => (
                    <div key={video.videoId} className="glass rounded-xl overflow-hidden card-hover">
                      <a href={`https://youtube.com/watch?v=${video.videoId}`} target="_blank" rel="noopener noreferrer">
                        <div className="relative">
                          <img src={video.thumbnail} alt={video.title} className="w-full aspect-video object-cover" />
                          <span className="absolute bottom-2 right-2 bg-black/80 px-2 py-0.5 rounded text-xs">
                            {formatDuration(video.duration)}
                          </span>
                          <span className="absolute top-2 left-2 bg-blue-600/80 px-2 py-0.5 rounded text-xs">
                            {video.category}
                          </span>
                        </div>
                      </a>
                      <div className="p-3">
                        <h3 className="font-medium line-clamp-2 text-sm mb-2">{video.title}</h3>
                        <div className="flex items-center justify-between text-xs text-gray-400 mb-3">
                          <span>{video.channelTitle}</span>
                          <span>{formatNumber(video.viewCount)} 조회</span>
                        </div>
                        <div className="flex gap-2">
                          <button
                            onClick={() => handleChangeVideoCategory(video)}
                            className="p-2 bg-white/10 hover:bg-white/20 rounded-lg transition"
                            title="카테고리 변경"
                          >
                            <Icons.Folder />
                          </button>
                          <button
                            onClick={() => handleDeleteVideo(video.videoId)}
                            className="p-2 bg-red-600/20 hover:bg-red-600/40 rounded-lg transition text-red-400"
                          >
                            <Icons.Trash />
                          </button>
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              ) : (
                <div className="glass rounded-xl overflow-hidden">
                  <table className="w-full">
                    <thead className="bg-white/5">
                      <tr>
                        <th className="text-left p-3 text-sm">영상</th>
                        <th className="text-left p-3 text-sm">채널</th>
                        <th className="text-left p-3 text-sm">조회수</th>
                        <th className="text-left p-3 text-sm">좋아요</th>
                        <th className="text-left p-3 text-sm">카테고리</th>
                        <th className="text-left p-3 text-sm">업로드</th>
                        <th className="text-left p-3 text-sm">관리</th>
                      </tr>
                    </thead>
                    <tbody>
                      {filteredVideos.map(video => (
                        <tr key={video.videoId} className="border-t border-white/5 hover:bg-white/5">
                          <td className="p-3">
                            <div className="flex items-center gap-3">
                              <a href={`https://youtube.com/watch?v=${video.videoId}`} target="_blank" rel="noopener noreferrer">
                                <img src={video.thumbnail} alt="" className="w-24 aspect-video object-cover rounded" />
                              </a>
                              <span className="text-sm line-clamp-2 max-w-xs">{video.title}</span>
                            </div>
                          </td>
                          <td className="p-3 text-sm text-gray-400">{video.channelTitle}</td>
                          <td className="p-3 text-sm">{formatNumber(video.viewCount)}</td>
                          <td className="p-3 text-sm">{formatNumber(video.likeCount)}</td>
                          <td className="p-3">
                            <span className="bg-blue-600/30 px-2 py-1 rounded text-xs">{video.category}</span>
                          </td>
                          <td className="p-3 text-sm text-gray-400">{formatDate(video.publishedAt)}</td>
                          <td className="p-3">
                            <div className="flex gap-2">
                              <button
                                onClick={() => handleChangeVideoCategory(video)}
                                className="p-1.5 bg-white/10 hover:bg-white/20 rounded transition"
                              >
                                <Icons.Folder />
                              </button>
                              <button
                                onClick={() => handleDeleteVideo(video.videoId)}
                                className="p-1.5 bg-red-600/20 hover:bg-red-600/40 rounded transition text-red-400"
                              >
                                <Icons.Trash />
                              </button>
                            </div>
                          </td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              )}
            </div>
          )}

          {/* 채널 보관함 탭 */}
          {currentTab === 'channels' && (
            <div className="space-y-4">
              <div className="glass rounded-xl p-4">
                <div className="flex items-center justify-between">
                  <div className="flex gap-2">
                    <select
                      value={selectedCategory}
                      onChange={(e) => setSelectedCategory(e.target.value)}
                      className="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm"
                    >
                      <option value="전체">전체 카테고리</option>
                      {getExistingCategories().map(cat => (
                        <option key={cat} value={cat}>{cat}</option>
                      ))}
                    </select>
                  </div>
                  
                  <button
                    onClick={() => setIsAddChannelOpen(true)}
                    className="flex items-center gap-2 bg-green-600 hover:bg-green-700 px-4 py-2 rounded-lg text-sm transition"
                  >
                    <Icons.Plus />
                    채널 추가
                  </button>
                </div>
              </div>

              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
                {filteredChannels.map(channel => (
                  <div key={channel.channelId} className="glass rounded-xl p-4 card-hover">
                    <div className="flex items-center gap-3 mb-3">
                      <a href={`https://youtube.com/channel/${channel.channelId}`} target="_blank" rel="noopener noreferrer">
                        <img src={channel.thumbnail} alt="" className="w-12 h-12 rounded-full" />
                      </a>
                      <div className="flex-1 min-w-0">
                        <h3 className="font-medium truncate">{channel.channelTitle}</h3>
                        <p className="text-sm text-gray-400">구독자 {formatNumber(channel.subscriberCount)}</p>
                      </div>
                    </div>
                    <div className="flex items-center justify-between">
                      <span className="bg-purple-600/30 px-2 py-1 rounded text-xs">{channel.category}</span>
                      <div className="flex gap-2">
                        <button
                          onClick={() => handleChangeCategory(channel)}
                          className="p-2 bg-white/10 hover:bg-white/20 rounded-lg transition"
                          title="카테고리 변경"
                        >
                          <Icons.Folder />
                        </button>
                        <button
                          onClick={() => handleDeleteChannel(channel.channelId)}
                          className="p-2 bg-red-600/20 hover:bg-red-600/40 rounded-lg transition text-red-400"
                        >
                          <Icons.Trash />
                        </button>
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* 토스트 */}
          {toast && (
            <div className={`fixed bottom-4 right-4 px-4 py-2 rounded-lg ${
              toast.type === 'error' ? 'bg-red-600' : toast.type === 'info' ? 'bg-blue-600' : 'bg-green-600'
            } shadow-lg z-50`}>
              {toast.message}
            </div>
          )}

          {/* 설정 모달 */}
          {isSettingsOpen && (
            <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
              <div className="glass rounded-xl p-6 w-full max-w-lg max-h-[80vh] overflow-y-auto">
                <div className="flex items-center justify-between mb-4">
                  <h2 className="text-xl font-bold">설정</h2>
                  <button onClick={() => setIsSettingsOpen(false)} className="p-2 hover:bg-white/10 rounded-lg">
                    <Icons.X />
                  </button>
                </div>
                
                {/* API 키 관리 */}
                <div className="mb-6">
                  <h3 className="font-medium mb-3 flex items-center gap-2">
                    <Icons.Key />
                    API 키 관리
                  </h3>
                  
                  <div className="space-y-2">
                    {API_KEYS.map((key, index) => {
                      const usage = keyQuotas.keys[index]?.used || 0;
                      const percent = (usage / DAILY_QUOTA_LIMIT) * 100;
                      const isActive = index === currentKeyIndex;
                      
                      return (
                        <div 
                          key={index}
                          className={`p-3 rounded-lg border ${isActive ? 'border-blue-500 bg-blue-500/10' : 'border-white/10 bg-white/5'}`}
                        >
                          <div className="flex items-center justify-between mb-2">
                            <span className="text-sm font-medium">
                              키 {index + 1} {isActive && '(사용 중)'}
                            </span>
                            <button
                              onClick={() => switchApiKey(index)}
                              disabled={isActive}
                              className={`text-xs px-2 py-1 rounded ${isActive ? 'bg-gray-600' : 'bg-blue-600 hover:bg-blue-700'}`}
                            >
                              {isActive ? '현재 키' : '전환'}
                            </button>
                          </div>
                          <div className="w-full h-2 bg-gray-700 rounded-full overflow-hidden">
                            <div 
                              className={`h-full transition-all ${
                                percent >= 80 ? 'bg-red-500' : percent >= 70 ? 'bg-yellow-500' : 'bg-green-500'
                              }`}
                              style={{ width: `${Math.min(percent, 100)}%` }}
                            />
                          </div>
                          <div className="flex justify-between mt-1 text-xs text-gray-400">
                            <span>{usage.toLocaleString()} / {DAILY_QUOTA_LIMIT.toLocaleString()}</span>
                            <span>{percent.toFixed(1)}%</span>
                          </div>
                        </div>
                      );
                    })}
                  </div>
                  
                  <button
                    onClick={resetQuotas}
                    className="mt-3 w-full bg-white/10 hover:bg-white/20 py-2 rounded-lg text-sm transition flex items-center justify-center gap-2"
                  >
                    <Icons.Refresh />
                    사용량 초기화
                  </button>
                </div>
                
                {/* Supabase 설정 */}
                <div className="space-y-3">
                  <h3 className="font-medium">Supabase 설정</h3>
                  <div>
                    <label className="block text-sm text-gray-400 mb-1">Supabase URL</label>
                    <input
                      type="text"
                      value={settings.supabaseUrl}
                      onChange={(e) => setSettings(s => ({ ...s, supabaseUrl: e.target.value }))}
                      className="w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm"
                      placeholder="https://xxx.supabase.co"
                    />
                  </div>
                  <div>
                    <label className="block text-sm text-gray-400 mb-1">Supabase Anon Key</label>
                    <input
                      type="password"
                      value={settings.supabaseKey}
                      onChange={(e) => setSettings(s => ({ ...s, supabaseKey: e.target.value }))}
                      className="w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm"
                      placeholder="eyJhbGciOiJIUzI1NiIsInR5cCI6..."
                    />
                  </div>
                </div>
              </div>
            </div>
          )}

          {/* 채널 추가 모달 */}
          {isAddChannelOpen && (
            <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
              <div className="glass rounded-xl p-6 w-full max-w-md">
                <div className="flex items-center justify-between mb-4">
                  <h2 className="text-lg font-bold">채널 직접 추가</h2>
                  <button onClick={() => setIsAddChannelOpen(false)} className="p-2 hover:bg-white/10 rounded-lg">
                    <Icons.X />
                  </button>
                </div>
                
                <input
                  type="text"
                  value={channelInput}
                  onChange={(e) => setChannelInput(e.target.value)}
                  placeholder="채널 URL 또는 @핸들"
                  className="w-full bg-white/10 border border-white/20 rounded-lg px-4 py-2 mb-3"
                />
                
                <p className="text-xs text-gray-400 mb-4">
                  💡 UC... 형식 ID로 추가하면 1쿼터, @핸들은 101쿼터 소모
                </p>
                
                <button
                  onClick={handleAddChannelByUrl}
                  disabled={!channelInput.trim() || isAddingChannel}
                  className="w-full bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 py-2 rounded-lg transition"
                >
                  {isAddingChannel ? '추가 중...' : '채널 추가'}
                </button>
              </div>
            </div>
          )}

          {/* 영상 추가 모달 */}
          {isAddVideoOpen && (
            <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
              <div className="glass rounded-xl p-6 w-full max-w-md">
                <div className="flex items-center justify-between mb-4">
                  <h2 className="text-lg font-bold">영상 직접 추가</h2>
                  <button onClick={() => setIsAddVideoOpen(false)} className="p-2 hover:bg-white/10 rounded-lg">
                    <Icons.X />
                  </button>
                </div>
                
                <input
                  type="text"
                  value={videoInput}
                  onChange={(e) => setVideoInput(e.target.value)}
                  placeholder="YouTube 영상 URL"
                  className="w-full bg-white/10 border border-white/20 rounded-lg px-4 py-2 mb-3"
                />
                
                <p className="text-xs text-gray-400 mb-4">
                  💡 영상 추가 시 약 2쿼터 소모
                </p>
                
                <button
                  onClick={handleAddVideoByUrl}
                  disabled={!videoInput.trim() || isAddingVideo}
                  className="w-full bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 py-2 rounded-lg transition"
                >
                  {isAddingVideo ? '추가 중...' : '영상 추가'}
                </button>
              </div>
            </div>
          )}

          {/* 채널 카테고리 선택 모달 */}
          {isCategoryModalOpen && pendingChannel && (
            <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
              <div className="glass rounded-xl p-6 w-full max-w-md">
                <div className="flex items-center justify-between mb-4">
                  <h2 className="text-lg font-bold">
                    {categoryChangeMode ? '카테고리 변경' : '카테고리 선택'}
                  </h2>
                  <button 
                    onClick={() => {
                      setIsCategoryModalOpen(false);
                      setPendingChannel(null);
                      setCategoryChangeMode(false);
                    }} 
                    className="p-2 hover:bg-white/10 rounded-lg"
                  >
                    <Icons.X />
                  </button>
                </div>
                
                <div className="flex items-center gap-3 mb-4 p-3 bg-white/5 rounded-lg">
                  <img src={pendingChannel.thumbnail} alt="" className="w-10 h-10 rounded-full" />
                  <div>
                    <p className="font-medium">{pendingChannel.channelTitle}</p>
                    <p className="text-sm text-gray-400">구독자 {formatNumber(pendingChannel.subscriberCount)}</p>
                  </div>
                </div>
                
                <div className="space-y-2 mb-4">
                  <p className="text-sm text-gray-400">기존 카테고리</p>
                  <div className="flex flex-wrap gap-2">
                    {getExistingCategories().length > 0 ? (
                      getExistingCategories().map(cat => (
                        <button
                          key={cat}
                          onClick={() => confirmSaveChannel(cat)}
                          className="px-3 py-1.5 bg-purple-600/30 hover:bg-purple-600/50 rounded-lg text-sm transition"
                        >
                          {cat}
                        </button>
                      ))
                    ) : (
                      <p className="text-gray-500 text-sm">저장된 카테고리가 없습니다</p>
                    )}
                  </div>
                </div>
                
                <div className="space-y-2">
                  <p className="text-sm text-gray-400">새 카테고리 만들기</p>
                  <div className="flex gap-2">
                    <input
                      type="text"
                      placeholder="카테고리명 입력"
                      className="flex-1 bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm"
                      onKeyPress={(e) => {
                        if (e.key === 'Enter' && e.target.value.trim()) {
                          confirmSaveChannel(e.target.value.trim());
                        }
                      }}
                    />
                    <button
                      onClick={(e) => {
                        const input = e.target.previousSibling;
                        if (input.value.trim()) {
                          confirmSaveChannel(input.value.trim());
                        }
                      }}
                      className="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded-lg text-sm transition"
                    >
                      저장
                    </button>
                  </div>
                </div>
              </div>
            </div>
          )}

          {/* 영상 카테고리 선택 모달 */}
          {isVideoCategoryModalOpen && pendingVideoData && (
            <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
              <div className="glass rounded-xl p-6 w-full max-w-md">
                <div className="flex items-center justify-between mb-4">
                  <h2 className="text-lg font-bold">
                    {categoryChangeMode ? '카테고리 변경' : '카테고리 선택'}
                  </h2>
                  <button 
                    onClick={() => {
                      setIsVideoCategoryModalOpen(false);
                      setPendingVideoData(null);
                      setCategoryChangeMode(false);
                    }} 
                    className="p-2 hover:bg-white/10 rounded-lg"
                  >
                    <Icons.X />
                  </button>
                </div>
                
                <div className="mb-4 p-3 bg-white/5 rounded-lg">
                  <div className="flex gap-3">
                    <img src={pendingVideoData.thumbnail} alt="" className="w-20 aspect-video object-cover rounded" />
                    <div className="flex-1 min-w-0">
                      <p className="font-medium text-sm line-clamp-2">{pendingVideoData.title}</p>
                      <p className="text-xs text-gray-400 mt-1">{pendingVideoData.channelTitle}</p>
                    </div>
                  </div>
                </div>
                
                <div className="space-y-2 mb-4">
                  <p className="text-sm text-gray-400">기존 카테고리</p>
                  <div className="flex flex-wrap gap-2">
                    {getExistingVideoCategories().length > 0 ? (
                      getExistingVideoCategories().map(cat => (
                        <button
                          key={cat}
                          onClick={() => confirmSaveVideoWithCategory(cat)}
                          className="px-3 py-1.5 bg-blue-600/30 hover:bg-blue-600/50 rounded-lg text-sm transition"
                        >
                          {cat}
                        </button>
                      ))
                    ) : (
                      <p className="text-gray-500 text-sm">저장된 카테고리가 없습니다</p>
                    )}
                  </div>
                </div>
                
                <div className="space-y-2">
                  <p className="text-sm text-gray-400">새 카테고리 만들기</p>
                  <div className="flex gap-2">
                    <input
                      type="text"
                      placeholder="카테고리명 입력"
                      className="flex-1 bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm"
                      onKeyPress={(e) => {
                        if (e.key === 'Enter' && e.target.value.trim()) {
                          confirmSaveVideoWithCategory(e.target.value.trim());
                        }
                      }}
                    />
                    <button
                      onClick={(e) => {
                        const input = e.target.previousSibling;
                        if (input.value.trim()) {
                          confirmSaveVideoWithCategory(input.value.trim());
                        }
                      }}
                      className="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded-lg text-sm transition"
                    >
                      저장
                    </button>
                  </div>
                </div>
              </div>
            </div>
          )}
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>

